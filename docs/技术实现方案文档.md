# GitHub Global - æŠ€æœ¯å®ç°æ–¹æ¡ˆæ–‡æ¡£

> ç‰ˆæœ¬ï¼šv1.0.0
> æ—¥æœŸï¼š2026-01-21
> ä½œè€…ï¼šæŠ€æœ¯æ¶æ„å¸ˆ
> çŠ¶æ€ï¼šå¾…è¯„å®¡

---

## 1. æ–‡æ¡£æ¦‚è¿°

### 1.1 æ–‡æ¡£ç›®çš„

æœ¬æ–‡æ¡£åŸºäºã€Šéœ€æ±‚è§„æ ¼æ–‡æ¡£ v1.0.0ã€‹ï¼Œè¯¦ç»†æè¿° GitHub Global é¡¹ç›®çš„æŠ€æœ¯å®ç°æ–¹æ¡ˆï¼ŒåŒ…æ‹¬æŠ€æœ¯æ¶æ„ã€æ ¸å¿ƒæ¨¡å—è®¾è®¡ã€API æ¥å£è§„èŒƒã€æ•°æ®åº“è®¾è®¡ã€ç¬¬ä¸‰æ–¹æœåŠ¡é›†æˆç­‰å†…å®¹ã€‚

### 1.2 é€‚ç”¨èŒƒå›´

- MVPï¼ˆæœ€å°å¯è¡Œäº§å“ï¼‰é˜¶æ®µçš„æŠ€æœ¯å®ç°
- å¼€å‘å›¢é˜Ÿçš„æŠ€æœ¯å‚è€ƒ

### 1.3 æŠ€æœ¯è°ƒç ”æ¥æº

- GitHub REST API å®˜æ–¹æ–‡æ¡£ï¼ˆ2025-2026ï¼‰
- GitHub App å®˜æ–¹æ–‡æ¡£
- OpenRouter API å®˜æ–¹æ–‡æ¡£
- ä¸šç•Œæœ€ä½³å®è·µ

---

## 2. æŠ€æœ¯æ ˆé€‰å‹

### 2.1 æŠ€æœ¯æ ˆæ€»è§ˆ

| å±‚çº§ | æŠ€æœ¯é€‰å‹ | ç‰ˆæœ¬è¦æ±‚ | é€‰å‹ç†ç”± |
|------|----------|----------|----------|
| **å‰ç«¯æ¡†æ¶** | Next.js 15 (App Router) | ^15.0.0 | 2025-2026å¹´ä¸»æµå…¨æ ˆæ¡†æ¶ï¼›SSR/SSG æ”¯æŒï¼›TypeScript åŸç”Ÿæ”¯æŒï¼›React 19 æ”¯æŒ |
| **UI ç»„ä»¶åº“** | shadcn/ui + Tailwind CSS | æœ€æ–°ç‰ˆ | ç°ä»£åŒ–è®¾è®¡ï¼›é«˜åº¦å¯å®šåˆ¶ï¼›æ€§èƒ½ä¼˜ç§€ï¼›æ— è¿è¡Œæ—¶ä¾èµ– |
| **ç¼–ç¨‹è¯­è¨€** | TypeScript | ^5.0.0 | ç±»å‹å®‰å…¨ï¼›å¼€å‘ä½“éªŒä¼˜ç§€ï¼›IDE æ”¯æŒå®Œå–„ |
| **æ•°æ®åº“** | MySQL | ^8.0 | æˆç†Ÿç¨³å®šï¼›å¹¿æ³›ä½¿ç”¨ï¼›æ˜“äºè¿ç»´ |
| **ORM** | Prisma | ^6.0.0 | ç±»å‹å®‰å…¨ï¼›è¿ç§»ç®¡ç†ï¼›æŸ¥è¯¢æ„å»ºå™¨ |
| **åå°ä»»åŠ¡é˜Ÿåˆ—** | æœ¬åœ°ä»»åŠ¡é˜Ÿåˆ—ï¼ˆå¯æ‰©å±•ä¸º BullMQ + Redisï¼‰ | - | MVP é˜¶æ®µä½¿ç”¨æœ¬åœ°é˜Ÿåˆ—ï¼Œåç»­æ‰©å±•ä¸º Redis |
| **AI æ¥å…¥** | OpenRouter API | - | ç»Ÿä¸€æ¥å…¥å¤šç§æ¨¡å‹ï¼›æ”¯æŒ fallbackï¼›æˆæœ¬ä¼˜åŒ– |
| **GitHub é›†æˆ** | GitHub App + Octokit | - | ç»†ç²’åº¦æƒé™æ§åˆ¶ï¼›Token è‡ªåŠ¨è¿‡æœŸï¼›æ›´å®‰å…¨ |
| **èº«ä»½è®¤è¯** | NextAuth.js v5 | ^5.0.0 | GitHub App OAuth é›†æˆï¼›Session ç®¡ç† |
| **éƒ¨ç½²æ–¹å¼** | Docker å®¹å™¨åŒ– | - | å¯ç§»æ¤æ€§ï¼›ç¯å¢ƒä¸€è‡´æ€§ï¼›æ˜“äºæ‰©å±• |

### 2.2 é¡¹ç›®ç»“æ„

```
github-global/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ app/                      # Next.js App Router é¡µé¢
â”‚   â”‚   â”œâ”€â”€ (auth)/              # è®¤è¯ç›¸å…³é¡µé¢
â”‚   â”‚   â”‚   â”œâ”€â”€ login/
â”‚   â”‚   â”‚   â””â”€â”€ callback/
â”‚   â”‚   â”œâ”€â”€ (dashboard)/         # ä»ªè¡¨ç›˜é¡µé¢
â”‚   â”‚   â”‚   â”œâ”€â”€ dashboard/
â”‚   â”‚   â”‚   â”œâ”€â”€ repo/[id]/
â”‚   â”‚   â”‚   â”œâ”€â”€ task/[id]/
â”‚   â”‚   â”‚   â””â”€â”€ settings/
â”‚   â”‚   â”œâ”€â”€ api/                 # API è·¯ç”±
â”‚   â”‚   â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â”‚   â”œâ”€â”€ github/
â”‚   â”‚   â”‚   â”œâ”€â”€ repos/
â”‚   â”‚   â”‚   â”œâ”€â”€ translations/
â”‚   â”‚   â”‚   â””â”€â”€ webhooks/
â”‚   â”‚   â”œâ”€â”€ layout.tsx
â”‚   â”‚   â””â”€â”€ page.tsx
â”‚   â”œâ”€â”€ components/              # React ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ ui/                  # shadcn/ui åŸºç¡€ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ layout/              # å¸ƒå±€ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ repo/                # ä»“åº“ç›¸å…³ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ translation/         # ç¿»è¯‘ç›¸å…³ç»„ä»¶
â”‚   â”‚   â””â”€â”€ common/              # é€šç”¨ç»„ä»¶
â”‚   â”œâ”€â”€ lib/                     # æ ¸å¿ƒåº“
â”‚   â”‚   â”œâ”€â”€ github/              # GitHub API å°è£…
â”‚   â”‚   â”œâ”€â”€ openrouter/          # OpenRouter API å°è£…
â”‚   â”‚   â”œâ”€â”€ translation/         # ç¿»è¯‘å¼•æ“
â”‚   â”‚   â”œâ”€â”€ queue/               # ä»»åŠ¡é˜Ÿåˆ—
â”‚   â”‚   â”œâ”€â”€ db/                  # æ•°æ®åº“å·¥å…·
â”‚   â”‚   â””â”€â”€ utils/               # å·¥å…·å‡½æ•°
â”‚   â”œâ”€â”€ types/                   # TypeScript ç±»å‹å®šä¹‰
â”‚   â”œâ”€â”€ hooks/                   # React Hooks
â”‚   â””â”€â”€ config/                  # é…ç½®æ–‡ä»¶
â”œâ”€â”€ prisma/
â”‚   â””â”€â”€ schema.prisma            # æ•°æ®åº“ Schema
â”œâ”€â”€ public/                      # é™æ€èµ„æº
â”œâ”€â”€ docker/
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â””â”€â”€ docker-compose.yml
â”œâ”€â”€ docs/                        # æ–‡æ¡£
â”œâ”€â”€ tests/                       # æµ‹è¯•
â”œâ”€â”€ .env.example                 # ç¯å¢ƒå˜é‡ç¤ºä¾‹
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â””â”€â”€ tailwind.config.ts
```

---

## 3. GitHub App é›†æˆæ–¹æ¡ˆ

### 3.1 ä¸ºä»€ä¹ˆé€‰æ‹© GitHub App

æ ¹æ® GitHub å®˜æ–¹æ–‡æ¡£ï¼ˆ2025-2026ï¼‰ï¼ŒGitHub App ç›¸æ¯” OAuth App å…·æœ‰ä»¥ä¸‹ä¼˜åŠ¿ï¼š

| ç‰¹æ€§ | GitHub App | OAuth App |
|------|------------|-----------|
| æƒé™æ§åˆ¶ | ç»†ç²’åº¦æƒé™ï¼ˆå¦‚åªè¯» contentsï¼‰ | ç²—ç²’åº¦ scopesï¼ˆrepo åŒ…å«æ‰€æœ‰æƒé™ï¼‰ |
| Token è¿‡æœŸ | 1 å°æ—¶è‡ªåŠ¨è¿‡æœŸ | æ°¸ä¸è¿‡æœŸï¼ˆéœ€æ‰‹åŠ¨æ’¤é”€ï¼‰ |
| Rate Limit | å¯æ‰©å±•ï¼ˆåŸºäºå®‰è£…æ•°å’Œç”¨æˆ·æ•°ï¼‰ | å›ºå®š 5000/å°æ—¶/ç”¨æˆ· |
| ç‹¬ç«‹è¿è¡Œ | å¯ç‹¬ç«‹äºç”¨æˆ·è¿è¡Œ | å¿…é¡»ç»‘å®šç”¨æˆ· |
| Webhook | å†…ç½®é›†ä¸­ç®¡ç† | éœ€å•ç‹¬é…ç½® |

### 3.2 GitHub App é…ç½®

#### 3.2.1 åˆ›å»º GitHub App

åœ¨ GitHub Settings > Developer settings > GitHub Apps ä¸­åˆ›å»ºæ–°çš„ GitHub Appï¼š

**åŸºæœ¬ä¿¡æ¯ï¼š**
- **App Name**: `GitHub Global`
- **Homepage URL**: `https://your-domain.com`
- **Callback URL**: `https://your-domain.com/api/auth/callback/github`
- **Setup URL**: `https://your-domain.com/dashboard`ï¼ˆå®‰è£…åè·³è½¬ï¼‰
- **Webhook URL**: `https://your-domain.com/api/webhooks/github`
- **Webhook Secret**: éšæœºç”Ÿæˆçš„å¯†é’¥

#### 3.2.2 æƒé™é…ç½®

**Repository Permissionsï¼ˆä»“åº“æƒé™ï¼‰ï¼š**

| æƒé™ | çº§åˆ« | ç”¨é€” |
|------|------|------|
| **Contents** | Read & Write | è¯»å–ä»“åº“æ–‡ä»¶ã€åˆ›å»ºç¿»è¯‘æ–‡ä»¶ã€åˆ›å»ºåˆ†æ”¯ |
| **Metadata** | Read | è¯»å–ä»“åº“åŸºæœ¬ä¿¡æ¯ |
| **Pull requests** | Read & Write | åˆ›å»ºå’Œç®¡ç† Pull Request |
| **Webhooks** | Read & Write | æ¥æ”¶ä»“åº“äº‹ä»¶é€šçŸ¥ï¼ˆå¯é€‰ï¼Œç”¨äºè‡ªåŠ¨åŒæ­¥ï¼‰ |

**Account Permissionsï¼ˆè´¦æˆ·æƒé™ï¼‰ï¼š**

| æƒé™ | çº§åˆ« | ç”¨é€” |
|------|------|------|
| **Email addresses** | Read | è·å–ç”¨æˆ·é‚®ç®±ç”¨äº commit æäº¤ |

#### 3.2.3 Webhook äº‹ä»¶è®¢é˜…

| äº‹ä»¶ | ç”¨é€” |
|------|------|
| `push` | æ£€æµ‹ä»£ç å˜æ›´ï¼Œè§¦å‘å¢é‡ç¿»è¯‘ï¼ˆP2 åŠŸèƒ½ï¼‰ |
| `installation` | ç›‘å¬ App å®‰è£…/å¸è½½äº‹ä»¶ |
| `installation_repositories` | ç›‘å¬ä»“åº“æ·»åŠ /ç§»é™¤äº‹ä»¶ |

### 3.3 è®¤è¯æµç¨‹

#### 3.3.1 ç”¨æˆ·æˆæƒæµç¨‹ï¼ˆUser Access Tokenï¼‰

```mermaid
sequenceDiagram
    participant User as ç”¨æˆ·
    participant App as GitHub Global
    participant GitHub as GitHub

    User->>App: ç‚¹å‡»"ä½¿ç”¨ GitHub ç™»å½•"
    App->>GitHub: é‡å®šå‘åˆ° /login/oauth/authorize
    Note over GitHub: client_id, redirect_uri, state
    GitHub->>User: æ˜¾ç¤ºæˆæƒé¡µé¢
    User->>GitHub: ç¡®è®¤æˆæƒ
    GitHub->>App: å›è°ƒ redirect_uri?code=xxx&state=xxx
    App->>GitHub: POST /login/oauth/access_token
    Note over GitHub: client_id, client_secret, code
    GitHub->>App: è¿”å› access_token
    App->>App: å­˜å‚¨ç”¨æˆ·ä¿¡æ¯å’Œ token
    App->>User: ç™»å½•æˆåŠŸï¼Œè·³è½¬åˆ° Dashboard
```

**æˆæƒ URL æ„å»ºï¼š**

```typescript
const authUrl = new URL('https://github.com/login/oauth/authorize');
authUrl.searchParams.set('client_id', GITHUB_APP_CLIENT_ID);
authUrl.searchParams.set('redirect_uri', `${BASE_URL}/api/auth/callback/github`);
authUrl.searchParams.set('state', generateRandomState());
authUrl.searchParams.set('allow_signup', 'true');
```

#### 3.3.2 Installation Access Token è·å–

å½“éœ€è¦ä»¥ App èº«ä»½æ“ä½œä»“åº“æ—¶ï¼Œéœ€è¦è·å– Installation Access Tokenï¼š

```typescript
import { App } from 'octokit';

// åˆå§‹åŒ– GitHub App
const app = new App({
  appId: GITHUB_APP_ID,
  privateKey: GITHUB_APP_PRIVATE_KEY,
});

// è·å– Installation Access Token
async function getInstallationToken(installationId: number) {
  const octokit = await app.getInstallationOctokit(installationId);
  return octokit;
}
```

**Token ç¼“å­˜ç­–ç•¥ï¼š**
- Installation Access Token æœ‰æ•ˆæœŸ 1 å°æ—¶
- å®ç° Token ç¼“å­˜æœºåˆ¶ï¼Œåœ¨è¿‡æœŸå‰ 5 åˆ†é’Ÿåˆ·æ–°
- ç¼“å­˜ key: `github:installation:${installationId}:token`

### 3.4 å…³é”® API è°ƒç”¨

#### 3.4.1 è·å–ä»“åº“å†…å®¹

```typescript
// GET /repos/{owner}/{repo}/contents/{path}
async function getRepoContents(
  octokit: Octokit,
  owner: string,
  repo: string,
  path: string = ''
) {
  const { data } = await octokit.rest.repos.getContent({
    owner,
    repo,
    path,
  });
  return data;
}
```

#### 3.4.2 åˆ›å»ºåˆ†æ”¯

```typescript
// POST /repos/{owner}/{repo}/git/refs
async function createBranch(
  octokit: Octokit,
  owner: string,
  repo: string,
  branchName: string,
  baseSha: string
) {
  const { data } = await octokit.rest.git.createRef({
    owner,
    repo,
    ref: `refs/heads/${branchName}`,
    sha: baseSha,
  });
  return data;
}
```

#### 3.4.3 åˆ›å»º/æ›´æ–°æ–‡ä»¶

```typescript
// PUT /repos/{owner}/{repo}/contents/{path}
async function createOrUpdateFile(
  octokit: Octokit,
  owner: string,
  repo: string,
  path: string,
  content: string,
  message: string,
  branch: string,
  sha?: string  // æ›´æ–°æ—¶éœ€è¦æä¾›
) {
  const { data } = await octokit.rest.repos.createOrUpdateFileContents({
    owner,
    repo,
    path,
    message,
    content: Buffer.from(content).toString('base64'),
    branch,
    sha,
  });
  return data;
}
```

#### 3.4.4 åˆ›å»º Pull Request

```typescript
// POST /repos/{owner}/{repo}/pulls
async function createPullRequest(
  octokit: Octokit,
  owner: string,
  repo: string,
  title: string,
  body: string,
  head: string,  // æºåˆ†æ”¯
  base: string   // ç›®æ ‡åˆ†æ”¯
) {
  const { data } = await octokit.rest.pulls.create({
    owner,
    repo,
    title,
    body,
    head,
    base,
  });
  return data;
}
```

#### 3.4.5 æ¯”è¾ƒ Commitsï¼ˆå˜æ›´æ£€æµ‹ï¼‰

```typescript
// GET /repos/{owner}/{repo}/compare/{basehead}
async function compareCommits(
  octokit: Octokit,
  owner: string,
  repo: string,
  base: string,
  head: string
) {
  const { data } = await octokit.rest.repos.compareCommits({
    owner,
    repo,
    basehead: `${base}...${head}`,
  });
  return data;
}
```

### 3.5 Rate Limit å¤„ç†

GitHub API Rate Limitï¼š
- **è®¤è¯è¯·æ±‚**: 5,000 requests/hour/user
- **GitHub App**: å¯æ‰©å±•è‡³æ›´é«˜

**å¤„ç†ç­–ç•¥ï¼š**

```typescript
import { Octokit } from 'octokit';

const octokit = new Octokit({
  auth: token,
  throttle: {
    onRateLimit: (retryAfter, options) => {
      console.warn(`Rate limit hit, retrying after ${retryAfter}s`);
      if (options.request.retryCount <= 2) {
        return true; // é‡è¯•
      }
      return false;
    },
    onSecondaryRateLimit: (retryAfter, options) => {
      console.warn(`Secondary rate limit hit`);
      return false;
    },
  },
});
```

---

## 4. OpenRouter API é›†æˆæ–¹æ¡ˆ

### 4.1 OpenRouter æ¦‚è¿°

OpenRouter æä¾›ç»Ÿä¸€çš„ API æ¥å…¥å¤šç§ AI æ¨¡å‹ï¼Œæ”¯æŒï¼š
- OpenAI GPT ç³»åˆ—
- Anthropic Claude ç³»åˆ—
- Google Gemini ç³»åˆ—
- å…¶ä»–å¼€æºæ¨¡å‹

### 4.2 API é…ç½®

**åŸºç¡€é…ç½®ï¼š**

```typescript
// config/openrouter.ts
export const OPENROUTER_CONFIG = {
  baseUrl: 'https://openrouter.ai/api/v1',
  defaultModel: 'anthropic/claude-3.5-sonnet',
  fallbackModels: [
    'openai/gpt-4o',
    'google/gemini-pro-1.5',
  ],
  maxTokens: 4096,
  temperature: 0.3,  // ç¿»è¯‘ä»»åŠ¡ä½¿ç”¨è¾ƒä½æ¸©åº¦
};
```

### 4.3 Chat Completion API

**è¯·æ±‚æ ¼å¼ï¼š**

```typescript
// lib/openrouter/client.ts
interface ChatCompletionRequest {
  model: string;
  messages: Array<{
    role: 'system' | 'user' | 'assistant';
    content: string;
  }>;
  max_tokens?: number;
  temperature?: number;
  stream?: boolean;
}

async function createChatCompletion(
  request: ChatCompletionRequest,
  apiKey: string
): Promise<ChatCompletionResponse> {
  const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${apiKey}`,
      'Content-Type': 'application/json',
      'HTTP-Referer': 'https://github-global.com',
      'X-Title': 'GitHub Global',
    },
    body: JSON.stringify({
      model: request.model,
      messages: request.messages,
      max_tokens: request.max_tokens || 4096,
      temperature: request.temperature || 0.3,
      stream: request.stream || false,
    }),
  });

  if (!response.ok) {
    const error = await response.json();
    throw new OpenRouterError(error.error.message, response.status);
  }

  return response.json();
}
```

### 4.4 ç¿»è¯‘ Prompt è®¾è®¡

```typescript
// lib/translation/prompts.ts
export function buildTranslationPrompt(
  content: string,
  sourceLanguage: string,
  targetLanguage: string
): ChatCompletionRequest {
  return {
    model: 'anthropic/claude-3.5-sonnet',
    messages: [
      {
        role: 'system',
        content: `You are a professional technical documentation translator. Your task is to translate Markdown documents from ${sourceLanguage} to ${targetLanguage}.

Rules:
1. Preserve all Markdown formatting (headers, lists, code blocks, links, etc.)
2. Do NOT translate code snippets, variable names, function names
3. Do NOT translate URLs, file paths, or technical identifiers
4. Preserve the original document structure
5. Maintain a professional and accurate translation tone
6. Keep inline code (\`code\`) untranslated
7. Translate comments in code blocks if they are in the source language
8. Preserve all HTML tags and their attributes

Output only the translated content, no explanations.`,
      },
      {
        role: 'user',
        content: `Translate the following Markdown content:\n\n${content}`,
      },
    ],
    temperature: 0.3,
  };
}
```

### 4.5 Streaming å“åº”å¤„ç†

```typescript
// lib/openrouter/streaming.ts
async function* streamChatCompletion(
  request: ChatCompletionRequest,
  apiKey: string
): AsyncGenerator<string> {
  const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${apiKey}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      ...request,
      stream: true,
    }),
  });

  const reader = response.body?.getReader();
  const decoder = new TextDecoder();

  while (true) {
    const { done, value } = await reader!.read();
    if (done) break;

    const chunk = decoder.decode(value);
    const lines = chunk.split('\n').filter(line => line.startsWith('data: '));

    for (const line of lines) {
      const data = line.slice(6);
      if (data === '[DONE]') return;

      try {
        const parsed = JSON.parse(data);
        const content = parsed.choices[0]?.delta?.content;
        if (content) yield content;
      } catch {
        // å¿½ç•¥è§£æé”™è¯¯
      }
    }
  }
}
```

### 4.6 é”™è¯¯å¤„ç†ä¸é‡è¯•

```typescript
// lib/openrouter/retry.ts
interface RetryConfig {
  maxRetries: number;
  baseDelay: number;
  maxDelay: number;
}

async function withRetry<T>(
  fn: () => Promise<T>,
  config: RetryConfig = { maxRetries: 3, baseDelay: 1000, maxDelay: 30000 }
): Promise<T> {
  let lastError: Error | null = null;

  for (let attempt = 0; attempt < config.maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error as Error;

      if (error instanceof OpenRouterError) {
        // 401: æ— æ•ˆ API Keyï¼Œä¸é‡è¯•
        if (error.statusCode === 401) throw error;

        // 429: Rate Limitï¼Œç­‰å¾…åé‡è¯•
        if (error.statusCode === 429) {
          const delay = Math.min(
            config.baseDelay * Math.pow(2, attempt),
            config.maxDelay
          );
          await sleep(delay);
          continue;
        }

        // 503: æœåŠ¡ä¸å¯ç”¨ï¼Œä½¿ç”¨å¤‡ç”¨æ¨¡å‹
        if (error.statusCode === 503) {
          // è§¦å‘æ¨¡å‹ fallback
          throw new ModelUnavailableError(error.message);
        }
      }

      // å…¶ä»–é”™è¯¯ï¼ŒæŒ‡æ•°é€€é¿é‡è¯•
      const delay = Math.min(
        config.baseDelay * Math.pow(2, attempt),
        config.maxDelay
      );
      await sleep(delay);
    }
  }

  throw lastError;
}
```

### 4.7 æ¨¡å‹ Fallback ç­–ç•¥

```typescript
// lib/openrouter/fallback.ts
const MODEL_PRIORITY = [
  'anthropic/claude-3.5-sonnet',
  'openai/gpt-4o',
  'google/gemini-pro-1.5',
  'anthropic/claude-3-haiku',
];

async function translateWithFallback(
  content: string,
  sourceLanguage: string,
  targetLanguage: string,
  apiKey: string
): Promise<string> {
  for (const model of MODEL_PRIORITY) {
    try {
      const prompt = buildTranslationPrompt(content, sourceLanguage, targetLanguage);
      prompt.model = model;
      
      const response = await createChatCompletion(prompt, apiKey);
      return response.choices[0].message.content;
    } catch (error) {
      if (error instanceof ModelUnavailableError) {
        console.warn(`Model ${model} unavailable, trying next...`);
        continue;
      }
      throw error;
    }
  }

  throw new Error('All models unavailable');
}
```

### 4.8 å¹³å°æ‰˜ç®¡æ¨¡å¼ä¸é™æµ

**é™æµç­–ç•¥è®¾è®¡ï¼š**

```typescript
// lib/ratelimit/index.ts
interface RateLimitConfig {
  // å…è´¹ç”¨æˆ·æ¯æ—¥é™åˆ¶
  freeUserDailyLimit: number;
  // å…è´¹ç”¨æˆ·æ¯æ¬¡ç¿»è¯‘æ–‡ä»¶æ•°é™åˆ¶
  freeUserFilesPerRequest: number;
  // å…è´¹ç”¨æˆ·æ¯æ¬¡ç¿»è¯‘å­—ç¬¦æ•°é™åˆ¶
  freeUserCharsPerFile: number;
}

const DEFAULT_RATE_LIMIT: RateLimitConfig = {
  freeUserDailyLimit: 10,           // æ¯æ—¥ 10 æ¬¡ç¿»è¯‘ä»»åŠ¡
  freeUserFilesPerRequest: 5,       // æ¯æ¬¡æœ€å¤š 5 ä¸ªæ–‡ä»¶
  freeUserCharsPerFile: 50000,      // æ¯æ–‡ä»¶æœ€å¤š 50000 å­—ç¬¦
};

// ä½¿ç”¨æ•°æ®åº“è®°å½•ç”¨æˆ·ä½¿ç”¨é‡
async function checkRateLimit(userId: string): Promise<boolean> {
  const today = new Date().toISOString().split('T')[0];
  const usage = await prisma.userUsage.findFirst({
    where: {
      userId,
      date: today,
    },
  });

  return (usage?.count || 0) < DEFAULT_RATE_LIMIT.freeUserDailyLimit;
}

async function incrementUsage(userId: string): Promise<void> {
  const today = new Date().toISOString().split('T')[0];
  await prisma.userUsage.upsert({
    where: {
      userId_date: { userId, date: today },
    },
    update: {
      count: { increment: 1 },
    },
    create: {
      userId,
      date: today,
      count: 1,
    },
  });
}
```

---

## 5. æ•°æ®åº“è®¾è®¡

### 5.1 ER å›¾æ¦‚è¿°

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    User     â”‚â”€â”€â”€â”€<â”‚  Repository  â”‚â”€â”€â”€â”€<â”‚ TranslationTask â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                   â”‚                      â”‚
       â”‚                   â”‚                      â”‚
       â–¼                   â–¼                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  UserUsage  â”‚     â”‚  RepoConfig  â”‚     â”‚ TranslatedFile  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ApiKey    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.2 Prisma Schema

```prisma
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

// ç”¨æˆ·è¡¨
model User {
  id                String       @id @default(cuid())
  githubId          Int          @unique
  login             String       // GitHub ç”¨æˆ·å
  name              String?
  email             String?
  avatarUrl         String?
  accessToken       String       @db.Text  // åŠ å¯†å­˜å‚¨
  installationId    Int?         // GitHub App Installation ID
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt

  repositories      Repository[]
  translationTasks  TranslationTask[]
  userUsage         UserUsage[]
  apiKeys           ApiKey[]

  @@index([githubId])
  @@index([login])
}

// API Key è¡¨ï¼ˆç”¨æˆ·è‡ªå¸¦çš„ OpenRouter Keyï¼‰
model ApiKey {
  id          String   @id @default(cuid())
  userId      String
  provider    String   @default("openrouter")  // é¢„ç•™å…¶ä»– AI æä¾›å•†
  encryptedKey String  @db.Text               // AES-256 åŠ å¯†å­˜å‚¨
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// ç”¨æˆ·ä½¿ç”¨é‡è¡¨ï¼ˆç”¨äºé™æµï¼‰
model UserUsage {
  id        String   @id @default(cuid())
  userId    String
  date      String   // YYYY-MM-DD æ ¼å¼
  count     Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, date])
  @@index([userId])
  @@index([date])
}

// ä»“åº“è¡¨
model Repository {
  id              String   @id @default(cuid())
  userId          String
  githubRepoId    Int      @unique
  owner           String   // ä»“åº“æ‰€æœ‰è€…
  name            String   // ä»“åº“åç§°
  fullName        String   // owner/name
  description     String?  @db.Text
  defaultBranch   String   @default("main")
  isPrivate       Boolean  @default(false)
  lastSyncedAt    DateTime?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user            User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  config          RepoConfig?
  translationTasks TranslationTask[]

  @@index([userId])
  @@index([fullName])
}

// ä»“åº“é…ç½®è¡¨
model RepoConfig {
  id                String   @id @default(cuid())
  repositoryId      String   @unique
  baseLanguage      String   @default("zh-CN")  // åŸºå‡†è¯­è¨€
  targetLanguages   Json     // ç›®æ ‡è¯­è¨€åˆ—è¡¨ ["en", "ja", "ko"]
  includePaths      Json?    // åŒ…å«çš„è·¯å¾„ ["docs/**", "README.md"]
  excludePaths      Json?    // æ’é™¤çš„è·¯å¾„ ["docs/internal/**"]
  translationBranch String   @default("translations")  // ç¿»è¯‘åˆ†æ”¯å
  aiModel           String?  // æŒ‡å®šçš„ AI æ¨¡å‹ï¼ˆå¯é€‰ï¼‰
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  repository        Repository @relation(fields: [repositoryId], references: [id], onDelete: Cascade)
}

// ç¿»è¯‘ä»»åŠ¡è¡¨
model TranslationTask {
  id              String           @id @default(cuid())
  userId          String
  repositoryId    String
  status          TranslationStatus @default(PENDING)
  type            TaskType         @default(FULL)
  targetLanguages Json             // æœ¬æ¬¡ä»»åŠ¡çš„ç›®æ ‡è¯­è¨€
  totalFiles      Int              @default(0)
  completedFiles  Int              @default(0)
  failedFiles     Int              @default(0)
  progress        Float            @default(0)  // 0-100
  errorMessage    String?          @db.Text
  pullRequestUrl  String?          // PR é“¾æ¥
  pullRequestNumber Int?           // PR ç¼–å·
  startedAt       DateTime?
  completedAt     DateTime?
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  user            User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  repository      Repository       @relation(fields: [repositoryId], references: [id], onDelete: Cascade)
  translatedFiles TranslatedFile[]

  @@index([userId])
  @@index([repositoryId])
  @@index([status])
}

// ç¿»è¯‘æ–‡ä»¶è¡¨
model TranslatedFile {
  id                String        @id @default(cuid())
  translationTaskId String
  sourcePath        String        // æºæ–‡ä»¶è·¯å¾„
  targetPath        String        // ç¿»è¯‘åçš„è·¯å¾„
  targetLanguage    String        // ç›®æ ‡è¯­è¨€
  status            FileStatus    @default(PENDING)
  sourceContent     String?       @db.LongText
  translatedContent String?       @db.LongText
  tokensUsed        Int?          // æ¶ˆè€—çš„ token æ•°
  errorMessage      String?       @db.Text
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  translationTask   TranslationTask @relation(fields: [translationTaskId], references: [id], onDelete: Cascade)

  @@index([translationTaskId])
  @@index([status])
}

// ç¿»è¯‘ä»»åŠ¡çŠ¶æ€æšä¸¾
enum TranslationStatus {
  PENDING     // ç­‰å¾…ä¸­
  RUNNING     // è¿è¡Œä¸­
  COMPLETED   // å·²å®Œæˆ
  FAILED      // å¤±è´¥
  CANCELLED   // å·²å–æ¶ˆ
}

// ä»»åŠ¡ç±»å‹æšä¸¾
enum TaskType {
  FULL        // å…¨é‡ç¿»è¯‘
  INCREMENTAL // å¢é‡ç¿»è¯‘
}

// æ–‡ä»¶çŠ¶æ€æšä¸¾
enum FileStatus {
  PENDING     // ç­‰å¾…ä¸­
  TRANSLATING // ç¿»è¯‘ä¸­
  COMPLETED   // å·²å®Œæˆ
  FAILED      // å¤±è´¥
  SKIPPED     // å·²è·³è¿‡
}

// ç³»ç»Ÿé…ç½®è¡¨ï¼ˆç®¡ç†å‘˜é…ç½®ï¼‰
model SystemConfig {
  id          String   @id @default(cuid())
  key         String   @unique
  value       String   @db.Text
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}
```

### 5.3 åŠ å¯†å­˜å‚¨æ–¹æ¡ˆ

```typescript
// lib/crypto/index.ts
import { createCipheriv, createDecipheriv, randomBytes } from 'crypto';

const ALGORITHM = 'aes-256-gcm';
const KEY = Buffer.from(process.env.ENCRYPTION_KEY!, 'hex');  // 32 bytes

export function encrypt(plaintext: string): string {
  const iv = randomBytes(16);
  const cipher = createCipheriv(ALGORITHM, KEY, iv);

  let encrypted = cipher.update(plaintext, 'utf8', 'hex');
  encrypted += cipher.final('hex');

  const authTag = cipher.getAuthTag();

  // è¿”å›æ ¼å¼: iv:authTag:encrypted
  return `${iv.toString('hex')}:${authTag.toString('hex')}:${encrypted}`;
}

export function decrypt(ciphertext: string): string {
  const [ivHex, authTagHex, encrypted] = ciphertext.split(':');

  const iv = Buffer.from(ivHex, 'hex');
  const authTag = Buffer.from(authTagHex, 'hex');
  const decipher = createDecipheriv(ALGORITHM, KEY, iv);

  decipher.setAuthTag(authTag);

  let decrypted = decipher.update(encrypted, 'hex', 'utf8');
  decrypted += decipher.final('utf8');

  return decrypted;
}
```

---

## 6. æ ¸å¿ƒæ¨¡å—è®¾è®¡

### 6.1 ä»»åŠ¡é˜Ÿåˆ—æ¨¡å—

#### 6.1.1 æœ¬åœ°é˜Ÿåˆ—å®ç°ï¼ˆMVP é˜¶æ®µï¼‰

```typescript
// lib/queue/local-queue.ts
import { EventEmitter } from 'events';

interface Job<T> {
  id: string;
  data: T;
  status: 'pending' | 'running' | 'completed' | 'failed';
  result?: any;
  error?: Error;
  createdAt: Date;
  startedAt?: Date;
  completedAt?: Date;
}

class LocalQueue<T> extends EventEmitter {
  private jobs: Map<string, Job<T>> = new Map();
  private queue: string[] = [];
  private concurrency: number;
  private running: number = 0;
  private processor?: (data: T) => Promise<any>;

  constructor(concurrency: number = 3) {
    super();
    this.concurrency = concurrency;
  }

  setProcessor(fn: (data: T) => Promise<any>) {
    this.processor = fn;
  }

  async add(data: T): Promise<string> {
    const id = crypto.randomUUID();
    const job: Job<T> = {
      id,
      data,
      status: 'pending',
      createdAt: new Date(),
    };

    this.jobs.set(id, job);
    this.queue.push(id);
    this.process();

    return id;
  }

  private async process() {
    if (this.running >= this.concurrency || this.queue.length === 0) {
      return;
    }

    const jobId = this.queue.shift()!;
    const job = this.jobs.get(jobId)!;

    this.running++;
    job.status = 'running';
    job.startedAt = new Date();
    this.emit('active', job);

    try {
      job.result = await this.processor!(job.data);
      job.status = 'completed';
      job.completedAt = new Date();
      this.emit('completed', job);
    } catch (error) {
      job.status = 'failed';
      job.error = error as Error;
      job.completedAt = new Date();
      this.emit('failed', job, error);
    } finally {
      this.running--;
      this.process();
    }
  }

  getJob(id: string): Job<T> | undefined {
    return this.jobs.get(id);
  }

  getProgress(id: string): number {
    // å¯ä»¥é€šè¿‡ job data ä¸­çš„ progress å­—æ®µæ¥è·å–
    const job = this.jobs.get(id);
    return (job?.data as any)?.progress || 0;
  }
}

export const translationQueue = new LocalQueue(3);
```



### 6.2 ç¿»è¯‘å¼•æ“æ¨¡å—

```typescript
// lib/translation/engine.ts
import { prisma } from '@/lib/db';
import { getInstallationOctokit } from '@/lib/github/client';
import { translateWithFallback } from '@/lib/openrouter/fallback';
import { buildTranslationPrompt } from '@/lib/translation/prompts';
import { TranslationStatus, FileStatus } from '@prisma/client';

interface TranslationOptions {
  taskId: string;
  userId: string;
  repositoryId: string;
  targetLanguages: string[];
  onProgress?: (progress: number) => void;
}

export async function executeTranslation(options: TranslationOptions) {
  const { taskId, userId, repositoryId, targetLanguages, onProgress } = options;

  // æ›´æ–°ä»»åŠ¡çŠ¶æ€ä¸ºè¿è¡Œä¸­
  await prisma.translationTask.update({
    where: { id: taskId },
    data: {
      status: TranslationStatus.RUNNING,
      startedAt: new Date(),
    },
  });

  try {
    // 1. è·å–ä»“åº“ä¿¡æ¯å’Œé…ç½®
    const repository = await prisma.repository.findUnique({
      where: { id: repositoryId },
      include: { config: true, user: true },
    });

    if (!repository) throw new Error('Repository not found');

    // 2. è·å–ç”¨æˆ·çš„ API Keyï¼ˆä¼˜å…ˆç”¨æˆ·è‡ªå¸¦ï¼Œå¦åˆ™ä½¿ç”¨å¹³å°æ‰˜ç®¡ï¼‰
    const apiKey = await getApiKeyForUser(userId);

    // 3. è·å– GitHub Octokit å®¢æˆ·ç«¯
    const octokit = await getInstallationOctokit(repository.user.installationId!);

    // 4. è·å–å¾…ç¿»è¯‘çš„æ–‡ä»¶åˆ—è¡¨
    const filesToTranslate = await getFilesToTranslate(
      octokit,
      repository.owner,
      repository.name,
      repository.config
    );

    // 5. æ›´æ–°ä»»åŠ¡æ€»æ–‡ä»¶æ•°
    const totalFiles = filesToTranslate.length * targetLanguages.length;
    await prisma.translationTask.update({
      where: { id: taskId },
      data: { totalFiles },
    });

    // 6. åˆ›å»ºç¿»è¯‘åˆ†æ”¯
    const branchName = `translations-${Date.now()}`;
    const baseBranch = repository.defaultBranch;
    await createTranslationBranch(octokit, repository.owner, repository.name, branchName, baseBranch);

    // 7. é€ä¸ªç¿»è¯‘æ–‡ä»¶
    let completedFiles = 0;
    let failedFiles = 0;

    for (const file of filesToTranslate) {
      for (const targetLang of targetLanguages) {
        try {
          // åˆ›å»ºç¿»è¯‘æ–‡ä»¶è®°å½•
          const translatedFile = await prisma.translatedFile.create({
            data: {
              translationTaskId: taskId,
              sourcePath: file.path,
              targetPath: `translations/${targetLang}/${file.path}`,
              targetLanguage: targetLang,
              status: FileStatus.TRANSLATING,
              sourceContent: file.content,
            },
          });

          // è°ƒç”¨ AI ç¿»è¯‘
          const translatedContent = await translateWithFallback(
            file.content,
            repository.config?.baseLanguage || 'zh-CN',
            targetLang,
            apiKey
          );

          // å†™å…¥ GitHub
          await createOrUpdateFile(
            octokit,
            repository.owner,
            repository.name,
            `translations/${targetLang}/${file.path}`,
            translatedContent,
            `[GitHub Global] Translate ${file.path} to ${targetLang}`,
            branchName
          );

          // æ›´æ–°æ–‡ä»¶çŠ¶æ€
          await prisma.translatedFile.update({
            where: { id: translatedFile.id },
            data: {
              status: FileStatus.COMPLETED,
              translatedContent,
            },
          });

          completedFiles++;
        } catch (error) {
          console.error(`Failed to translate ${file.path} to ${targetLang}:`, error);
          failedFiles++;
          
          await prisma.translatedFile.updateMany({
            where: {
              translationTaskId: taskId,
              sourcePath: file.path,
              targetLanguage: targetLang,
            },
            data: {
              status: FileStatus.FAILED,
              errorMessage: (error as Error).message,
            },
          });
        }

        // æ›´æ–°è¿›åº¦
        const progress = ((completedFiles + failedFiles) / totalFiles) * 100;
        await prisma.translationTask.update({
          where: { id: taskId },
          data: { completedFiles, failedFiles, progress },
        });
        onProgress?.(progress);
      }
    }

    // 8. æ›´æ–° README å¤šè¯­è¨€é“¾æ¥
    await updateReadmeWithLanguageLinks(
      octokit,
      repository.owner,
      repository.name,
      targetLanguages,
      branchName
    );

    // 9. åˆ›å»º Pull Request
    const pr = await createPullRequest(
      octokit,
      repository.owner,
      repository.name,
      `[GitHub Global] Add translations for ${targetLanguages.join(', ')}`,
      buildPRDescription(targetLanguages, completedFiles, failedFiles),
      branchName,
      baseBranch
    );

    // 10. æ›´æ–°ä»»åŠ¡çŠ¶æ€ä¸ºå®Œæˆ
    await prisma.translationTask.update({
      where: { id: taskId },
      data: {
        status: TranslationStatus.COMPLETED,
        completedAt: new Date(),
        pullRequestUrl: pr.html_url,
        pullRequestNumber: pr.number,
      },
    });

    return { success: true, prUrl: pr.html_url };
  } catch (error) {
    // æ›´æ–°ä»»åŠ¡çŠ¶æ€ä¸ºå¤±è´¥
    await prisma.translationTask.update({
      where: { id: taskId },
      data: {
        status: TranslationStatus.FAILED,
        completedAt: new Date(),
        errorMessage: (error as Error).message,
      },
    });

    throw error;
  }
}

// è·å–ç”¨æˆ· API Key
async function getApiKeyForUser(userId: string): Promise<string> {
  // 1. ä¼˜å…ˆæŸ¥æ‰¾ç”¨æˆ·è‡ªå¸¦çš„ API Key
  const userApiKey = await prisma.apiKey.findFirst({
    where: { userId, provider: 'openrouter', isActive: true },
  });

  if (userApiKey) {
    return decrypt(userApiKey.encryptedKey);
  }

  // 2. ä½¿ç”¨å¹³å°æ‰˜ç®¡çš„ API Key
  const platformApiKey = await prisma.systemConfig.findUnique({
    where: { key: 'PLATFORM_OPENROUTER_API_KEY' },
  });

  if (!platformApiKey) {
    throw new Error('No API key available');
  }

  return decrypt(platformApiKey.value);
}
```

### 6.3 README å¤šè¯­è¨€é“¾æ¥ç”Ÿæˆ

```typescript
// lib/translation/readme-updater.ts

const LANGUAGE_NAMES: Record<string, string> = {
  'en': 'English',
  'zh-CN': 'ç®€ä½“ä¸­æ–‡',
  'zh-TW': 'ç¹é«”ä¸­æ–‡',
  'ja': 'æ—¥æœ¬èª',
  'ko': 'í•œêµ­ì–´',
  'es': 'EspaÃ±ol',
  'fr': 'FranÃ§ais',
  'de': 'Deutsch',
  'pt': 'PortuguÃªs',
  'ru': 'Ğ ÑƒÑÑĞºĞ¸Ğ¹',
  // ... æ›´å¤šè¯­è¨€
};

function generateLanguageLinks(languages: string[]): string {
  const links = languages.map(lang => {
    const name = LANGUAGE_NAMES[lang] || lang;
    return `[${name}](./translations/${lang}/README.md)`;
  });

  return `## ğŸŒ Translations

${links.join(' | ')}

---

`;
}

function findInsertPosition(content: string): number {
  // ç­–ç•¥1: å¦‚æœå·²æœ‰è¯­è¨€åˆ‡æ¢åŒºåŸŸï¼Œæ›´æ–°è¯¥åŒºåŸŸ
  const existingMatch = content.match(/## ğŸŒ.*?\n\n---\n\n/s);
  if (existingMatch) {
    return content.indexOf(existingMatch[0]);
  }

  // ç­–ç•¥2: åœ¨ç¬¬ä¸€ä¸ª ## æ ‡é¢˜ä¹‹å‰æ’å…¥
  const firstH2 = content.indexOf('\n## ');
  if (firstH2 !== -1) {
    return firstH2 + 1;
  }

  // ç­–ç•¥3: åœ¨ # æ ‡é¢˜ä¹‹åçš„ç¬¬ä¸€æ®µä¹‹åæ’å…¥
  const titleMatch = content.match(/^# .+\n\n/);
  if (titleMatch) {
    return titleMatch[0].length;
  }

  // ç­–ç•¥4: åœ¨æ–‡ä»¶å¼€å¤´æ’å…¥
  return 0;
}

export function insertLanguageLinks(content: string, languages: string[]): string {
  const links = generateLanguageLinks(languages);
  const position = findInsertPosition(content);

  // å¦‚æœå­˜åœ¨æ—§çš„è¯­è¨€é“¾æ¥åŒºåŸŸï¼Œå…ˆåˆ é™¤
  const cleanedContent = content.replace(/## ğŸŒ.*?\n\n---\n\n/s, '');

  return (
    cleanedContent.slice(0, position) +
    links +
    cleanedContent.slice(position)
  );
}
```

---

## 7. API æ¥å£è®¾è®¡

### 7.1 æ¥å£æ€»è§ˆ

| æ¨¡å— | è·¯å¾„ | æ–¹æ³• | è¯´æ˜ |
|------|------|------|------|
| è®¤è¯ | `/api/auth/[...nextauth]` | GET/POST | NextAuth.js å¤„ç† |
| ä»“åº“ | `/api/repos` | GET | è·å–ç”¨æˆ·ä»“åº“åˆ—è¡¨ |
| ä»“åº“ | `/api/repos` | POST | å¯¼å…¥ä»“åº“ |
| ä»“åº“ | `/api/repos/[id]` | GET | è·å–ä»“åº“è¯¦æƒ… |
| ä»“åº“ | `/api/repos/[id]/config` | PUT | æ›´æ–°ä»“åº“é…ç½® |
| ä»“åº“ | `/api/repos/[id]/files` | GET | è·å–ä»“åº“æ–‡ä»¶æ ‘ |
| ç¿»è¯‘ | `/api/translations` | POST | åˆ›å»ºç¿»è¯‘ä»»åŠ¡ |
| ç¿»è¯‘ | `/api/translations/[id]` | GET | è·å–ç¿»è¯‘ä»»åŠ¡è¯¦æƒ… |
| ç¿»è¯‘ | `/api/translations/[id]/progress` | GET | è·å–ç¿»è¯‘è¿›åº¦ï¼ˆSSEï¼‰ |
| è®¾ç½® | `/api/settings/api-key` | POST | ä¿å­˜ API Key |
| Webhook | `/api/webhooks/github` | POST | æ¥æ”¶ GitHub Webhook |

### 7.2 æ ¸å¿ƒæ¥å£å®šä¹‰

#### 7.2.1 åˆ›å»ºç¿»è¯‘ä»»åŠ¡

```typescript
// app/api/translations/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { prisma } from '@/lib/db';
import { checkRateLimit, incrementUsage } from '@/lib/ratelimit';
import { translationQueue } from '@/lib/queue';

export async function POST(request: NextRequest) {
  try {
    // 1. éªŒè¯ç”¨æˆ·èº«ä»½
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // 2. è§£æè¯·æ±‚ä½“
    const body = await request.json();
    const { repositoryId, targetLanguages, type = 'FULL' } = body;

    // 3. éªŒè¯å‚æ•°
    if (!repositoryId || !targetLanguages?.length) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      );
    }

    // 4. æ£€æŸ¥é™æµ
    const canProceed = await checkRateLimit(session.user.id);
    if (!canProceed) {
      return NextResponse.json(
        { error: 'Daily limit exceeded. Please try again tomorrow or add your own API key.' },
        { status: 429 }
      );
    }

    // 5. éªŒè¯ä»“åº“å½’å±
    const repository = await prisma.repository.findFirst({
      where: {
        id: repositoryId,
        userId: session.user.id,
      },
    });

    if (!repository) {
      return NextResponse.json(
        { error: 'Repository not found' },
        { status: 404 }
      );
    }

    // 6. åˆ›å»ºç¿»è¯‘ä»»åŠ¡
    const task = await prisma.translationTask.create({
      data: {
        userId: session.user.id,
        repositoryId,
        targetLanguages,
        type,
      },
    });

    // 7. å¢åŠ ä½¿ç”¨é‡è®¡æ•°
    await incrementUsage(session.user.id);

    // 8. æ·»åŠ åˆ°ä»»åŠ¡é˜Ÿåˆ—
    await translationQueue.add({
      taskId: task.id,
      userId: session.user.id,
      repositoryId,
      targetLanguages,
    });

    return NextResponse.json({
      success: true,
      taskId: task.id,
    });
  } catch (error) {
    console.error('Create translation task error:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

#### 7.2.2 ç¿»è¯‘è¿›åº¦ SSE

```typescript
// app/api/translations/[id]/progress/route.ts
import { NextRequest } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { prisma } from '@/lib/db';

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) {
    return new Response('Unauthorized', { status: 401 });
  }

  const taskId = params.id;

  // éªŒè¯ä»»åŠ¡å½’å±
  const task = await prisma.translationTask.findFirst({
    where: {
      id: taskId,
      userId: session.user.id,
    },
  });

  if (!task) {
    return new Response('Task not found', { status: 404 });
  }

  // åˆ›å»º SSE å“åº”
  const encoder = new TextEncoder();
  const stream = new ReadableStream({
    async start(controller) {
      const sendEvent = (data: object) => {
        controller.enqueue(
          encoder.encode(`data: ${JSON.stringify(data)}\n\n`)
        );
      };

      // è½®è¯¢ä»»åŠ¡çŠ¶æ€
      const pollInterval = setInterval(async () => {
        const currentTask = await prisma.translationTask.findUnique({
          where: { id: taskId },
          include: {
            translatedFiles: {
              select: {
                id: true,
                sourcePath: true,
                targetLanguage: true,
                status: true,
              },
            },
          },
        });

        if (!currentTask) {
          clearInterval(pollInterval);
          controller.close();
          return;
        }

        sendEvent({
          status: currentTask.status,
          progress: currentTask.progress,
          completedFiles: currentTask.completedFiles,
          totalFiles: currentTask.totalFiles,
          failedFiles: currentTask.failedFiles,
          files: currentTask.translatedFiles,
          pullRequestUrl: currentTask.pullRequestUrl,
        });

        // å¦‚æœä»»åŠ¡å®Œæˆæˆ–å¤±è´¥ï¼Œåœæ­¢è½®è¯¢
        if (['COMPLETED', 'FAILED', 'CANCELLED'].includes(currentTask.status)) {
          clearInterval(pollInterval);
          controller.close();
        }
      }, 1000);

      // æ¸…ç†
      request.signal.addEventListener('abort', () => {
        clearInterval(pollInterval);
        controller.close();
      });
    },
  });

  return new Response(stream, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
    },
  });
}
```

#### 7.2.3 è·å–ä»“åº“æ–‡ä»¶æ ‘

```typescript
// app/api/repos/[id]/files/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { prisma } from '@/lib/db';
import { getInstallationOctokit } from '@/lib/github/client';

interface FileTreeNode {
  name: string;
  path: string;
  type: 'file' | 'dir';
  children?: FileTreeNode[];
  isMarkdown?: boolean;
}

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const repository = await prisma.repository.findFirst({
      where: {
        id: params.id,
        userId: session.user.id,
      },
      include: { user: true },
    });

    if (!repository) {
      return NextResponse.json({ error: 'Repository not found' }, { status: 404 });
    }

    const octokit = await getInstallationOctokit(repository.user.installationId!);

    // é€’å½’è·å–æ–‡ä»¶æ ‘
    const tree = await getFileTree(
      octokit,
      repository.owner,
      repository.name,
      ''
    );

    return NextResponse.json({ tree });
  } catch (error) {
    console.error('Get file tree error:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

async function getFileTree(
  octokit: any,
  owner: string,
  repo: string,
  path: string
): Promise<FileTreeNode[]> {
  const { data } = await octokit.rest.repos.getContent({
    owner,
    repo,
    path,
  });

  const items = Array.isArray(data) ? data : [data];
  const result: FileTreeNode[] = [];

  for (const item of items) {
    const node: FileTreeNode = {
      name: item.name,
      path: item.path,
      type: item.type === 'dir' ? 'dir' : 'file',
    };

    if (item.type === 'file') {
      node.isMarkdown = item.name.endsWith('.md') || item.name.endsWith('.mdx');
    }

    if (item.type === 'dir' && !shouldSkipDirectory(item.name)) {
      node.children = await getFileTree(octokit, owner, repo, item.path);
    }

    result.push(node);
  }

  return result.sort((a, b) => {
    // ç›®å½•ä¼˜å…ˆ
    if (a.type !== b.type) return a.type === 'dir' ? -1 : 1;
    return a.name.localeCompare(b.name);
  });
}

function shouldSkipDirectory(name: string): boolean {
  const skipDirs = [
    'node_modules',
    '.git',
    '.github',
    'dist',
    'build',
    '.next',
    'vendor',
    '__pycache__',
  ];
  return skipDirs.includes(name);
}
```

---

## 8. éƒ¨ç½²æ–¹æ¡ˆ

### 8.1 Docker å®¹å™¨åŒ–éƒ¨ç½²

#### 8.1.1 Dockerfile

```dockerfile
# docker/Dockerfile
FROM node:20-alpine AS base

# å®‰è£…ä¾èµ–é˜¶æ®µ
FROM base AS deps
RUN apk add --no-cache libc6-compat
WORKDIR /app

COPY package.json package-lock.json* ./
RUN npm ci

# æ„å»ºé˜¶æ®µ
FROM base AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .

# ç”Ÿæˆ Prisma Client
RUN npx prisma generate

# æ„å»º Next.js
ENV NEXT_TELEMETRY_DISABLED 1
RUN npm run build

# ç”Ÿäº§é•œåƒ
FROM base AS runner
WORKDIR /app

ENV NODE_ENV production
ENV NEXT_TELEMETRY_DISABLED 1

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

COPY --from=builder /app/public ./public
COPY --from=builder /app/.next/standalone ./
COPY --from=builder /app/.next/static ./.next/static
COPY --from=builder /app/prisma ./prisma

USER nextjs

EXPOSE 3000

ENV PORT 3000
ENV HOSTNAME "0.0.0.0"

CMD ["node", "server.js"]
```

#### 8.1.2 docker-compose.yml

```yaml
# docker/docker-compose.yml
version: '3.8'

services:
  app:
    build:
      context: ..
      dockerfile: docker/Dockerfile
    ports:
      - "3000:3000"
    environment:
      - DATABASE_URL=mysql://user:password@db:3306/github_global
      - NEXTAUTH_URL=http://localhost:3000
      - NEXTAUTH_SECRET=${NEXTAUTH_SECRET}
      - GITHUB_APP_ID=${GITHUB_APP_ID}
      - GITHUB_APP_CLIENT_ID=${GITHUB_APP_CLIENT_ID}
      - GITHUB_APP_CLIENT_SECRET=${GITHUB_APP_CLIENT_SECRET}
      - GITHUB_APP_PRIVATE_KEY=${GITHUB_APP_PRIVATE_KEY}
      - ENCRYPTION_KEY=${ENCRYPTION_KEY}
      - PLATFORM_OPENROUTER_API_KEY=${PLATFORM_OPENROUTER_API_KEY}
    depends_on:
      db:
        condition: service_healthy
    restart: unless-stopped

  db:
    image: mysql:8.0
    environment:
      - MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD}
      - MYSQL_DATABASE=github_global
      - MYSQL_USER=user
      - MYSQL_PASSWORD=password
    volumes:
      - mysql_data:/var/lib/mysql
    ports:
      - "3306:3306"
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
      timeout: 20s
      retries: 10
    restart: unless-stopped

  # å¯é€‰ï¼šRedisï¼ˆç”¨äºç”Ÿäº§ç¯å¢ƒçš„ä»»åŠ¡é˜Ÿåˆ—ï¼‰
  # redis:
  #   image: redis:7-alpine
  #   ports:
  #     - "6379:6379"
  #   volumes:
  #     - redis_data:/data
  #   restart: unless-stopped

volumes:
  mysql_data:
  # redis_data:
```

### 8.2 ç¯å¢ƒå˜é‡é…ç½®

```bash
# .env.example

# æ•°æ®åº“
DATABASE_URL="mysql://user:password@localhost:3306/github_global"

# NextAuth
NEXTAUTH_URL="http://localhost:3000"
NEXTAUTH_SECRET="your-nextauth-secret-key"

# GitHub App
GITHUB_APP_ID="123456"
GITHUB_APP_CLIENT_ID="Iv1.xxxxxxxxxx"
GITHUB_APP_CLIENT_SECRET="xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
# ç§é’¥éœ€è¦ base64 ç¼–ç æˆ–ä½¿ç”¨å¤šè¡Œå­—ç¬¦ä¸²
GITHUB_APP_PRIVATE_KEY="-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----"
GITHUB_WEBHOOK_SECRET="your-webhook-secret"

# åŠ å¯†å¯†é’¥ï¼ˆ32 bytes hexï¼‰
ENCRYPTION_KEY="0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"

# å¹³å°æ‰˜ç®¡çš„ OpenRouter API Keyï¼ˆåŠ å¯†å­˜å‚¨ï¼‰
PLATFORM_OPENROUTER_API_KEY="sk-or-v1-xxxxxxxxxxxxxxxx"

# å¯é€‰ï¼šRedisï¼ˆç”Ÿäº§ç¯å¢ƒï¼‰
# REDIS_HOST="localhost"
# REDIS_PORT="6379"
# REDIS_PASSWORD=""
```

### 8.3 éƒ¨ç½²æµç¨‹

```bash
# 1. å…‹éš†ä»£ç 
git clone https://github.com/your-org/github-global.git
cd github-global

# 2. é…ç½®ç¯å¢ƒå˜é‡
cp .env.example .env
# ç¼–è¾‘ .env å¡«å…¥å®é™…é…ç½®

# 3. ä½¿ç”¨ Docker Compose å¯åŠ¨
cd docker
docker-compose up -d

# 4. è¿è¡Œæ•°æ®åº“è¿ç§»
docker-compose exec app npx prisma migrate deploy

# 5. æŸ¥çœ‹æ—¥å¿—
docker-compose logs -f app
```

---

## 9. å®‰å…¨è®¾è®¡

### 9.1 æ•æ„Ÿæ•°æ®ä¿æŠ¤

| æ•°æ®ç±»å‹ | ä¿æŠ¤æªæ–½ |
|----------|----------|
| GitHub Access Token | AES-256-GCM åŠ å¯†å­˜å‚¨ |
| OpenRouter API Key | AES-256-GCM åŠ å¯†å­˜å‚¨ |
| GitHub App Private Key | ç¯å¢ƒå˜é‡ï¼Œä¸å…¥åº“ |
| ç”¨æˆ·å¯†ç  | æ— å¯†ç ï¼ˆOAuth ç™»å½•ï¼‰ |

### 9.2 API å®‰å…¨

- æ‰€æœ‰ API æ¥å£éœ€è¦ Session è®¤è¯
- ä½¿ç”¨ CSRF Token é˜²æŠ¤
- Rate Limiting é˜²æ­¢æ»¥ç”¨
- è¾“å…¥éªŒè¯å’Œ SQL æ³¨å…¥é˜²æŠ¤ï¼ˆPrisma ORMï¼‰

### 9.3 Webhook å®‰å…¨

```typescript
// lib/github/webhook-verify.ts
import { createHmac } from 'crypto';

export function verifyWebhookSignature(
  payload: string,
  signature: string,
  secret: string
): boolean {
  const hmac = createHmac('sha256', secret);
  const digest = 'sha256=' + hmac.update(payload).digest('hex');

  return signature === digest;
}
```

---

## 10. å¼€å‘é‡Œç¨‹ç¢‘

### Phase 1: MVP åŸºç¡€åŠŸèƒ½

- [ ] é¡¹ç›®åˆå§‹åŒ–ã€æŠ€æœ¯æ¶æ„æ­å»º
  - [ ] Next.js 15 é¡¹ç›®åˆå§‹åŒ–
  - [ ] Prisma + MySQL é…ç½®
  - [ ] shadcn/ui ç»„ä»¶åº“é›†æˆ
  - [ ] Docker éƒ¨ç½²é…ç½®

- [ ] GitHub App é›†æˆ
  - [ ] åˆ›å»º GitHub App
  - [ ] OAuth ç™»å½•æµç¨‹
  - [ ] Installation Access Token è·å–

- [ ] ä»“åº“ç®¡ç†
  - [ ] ä»“åº“å¯¼å…¥åŠŸèƒ½
  - [ ] ä»“åº“åˆ—è¡¨å±•ç¤º
  - [ ] ä»“åº“è¯¦æƒ…é¡µé¢

- [ ] ç¿»è¯‘åŸºç¡€åŠŸèƒ½
  - [ ] è¯­è¨€é€‰æ‹©é…ç½®
  - [ ] OpenRouter API é›†æˆ
  - [ ] åŸºç¡€ç¿»è¯‘æ‰§è¡Œ
  - [ ] åˆ›å»ºåˆ†æ”¯å’Œ PR

### Phase 2: æ ¸å¿ƒåŠŸèƒ½å®Œå–„

- [ ] å¯è§†åŒ–ç¿»è¯‘èŒƒå›´é€‰æ‹©
- [ ] `.github-global-ignore` é…ç½®åŒæ­¥
- [ ] å˜æ›´æ£€æµ‹ä¸å¢é‡ç¿»è¯‘
- [ ] README å¤šè¯­è¨€é“¾æ¥è‡ªåŠ¨ç”Ÿæˆ
- [ ] ç¿»è¯‘è¿›åº¦å®æ—¶å±•ç¤ºï¼ˆSSEï¼‰

### Phase 3: ä½“éªŒä¼˜åŒ–

- [ ] ç¿»è¯‘ç»“æœé¢„è§ˆ
- [ ] ç¿»è¯‘å†å²è®°å½•
- [ ] é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶
- [ ] UI/UX ä¼˜åŒ–
- [ ] é™æµä¸ç”¨é‡ç»Ÿè®¡

---

## 11. é™„å½•

### 11.1 å‚è€ƒæ–‡æ¡£

- [GitHub REST API æ–‡æ¡£](https://docs.github.com/en/rest)
- [GitHub App æ–‡æ¡£](https://docs.github.com/en/apps/creating-github-apps)
- [OpenRouter API æ–‡æ¡£](https://openrouter.ai/docs)
- [Next.js 15 æ–‡æ¡£](https://nextjs.org/docs)
- [Prisma æ–‡æ¡£](https://www.prisma.io/docs)

### 11.2 æŠ€æœ¯å†³ç­–è®°å½•

| å†³ç­–é¡¹ | é€‰æ‹© | ç†ç”± |
|--------|------|------|
| è®¤è¯æ–¹å¼ | GitHub App | ç»†ç²’åº¦æƒé™ã€Token è‡ªåŠ¨è¿‡æœŸã€æ›´å®‰å…¨ |
| æ•°æ®åº“ | MySQL | æˆç†Ÿç¨³å®šã€æ˜“äºè¿ç»´ |
| ä»»åŠ¡é˜Ÿåˆ— | æœ¬åœ°é˜Ÿåˆ—ï¼ˆå¯æ‰©å±• Redisï¼‰ | MVP ç®€åŒ–ã€åç»­å¯æ‰©å±• |
| ç¿»è¯‘ç»“æœæäº¤ | åˆ›å»º PR | ç”¨æˆ·è‡ªä¸»æ§åˆ¶åˆå¹¶æ—¶æœº |
| éƒ¨ç½²æ–¹å¼ | Docker | å¯ç§»æ¤ã€ç¯å¢ƒä¸€è‡´ |

---

## æ–‡æ¡£å˜æ›´è®°å½•

| ç‰ˆæœ¬ | æ—¥æœŸ | ä¿®æ”¹å†…å®¹ | ä¿®æ”¹äºº |
|------|------|----------|--------|
| v1.0.0 | 2026-01-21 | åˆå§‹ç‰ˆæœ¬ | æŠ€æœ¯æ¶æ„å¸ˆ |
